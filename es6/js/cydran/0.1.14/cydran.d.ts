// Generated by dts-bundle-generator v4.3.0

/**
 * The piece of code between the HTMLElement and the Mvvm
 * @type M {@link ModelMediator}
 * @type E extends HTMLElement
 * @implements {@link Disposable}
 */
export declare abstract class ElementMediator<M, E extends HTMLElement | Text, P> implements Disposable, MediatorSource {
	private logger;
	private ____internal$$cydran____;
	private mediator;
	private pubSub;
	private propagation;
	private domListeners;
	private id;
	private params;
	private reducerFn?;
	constructor(dependencies: any, propagation: boolean, reducerFn: (input: any) => M);
	/**
	 * Dispose of ElementMediator when released.
	 * + All event listeners will be removed.
	 * + This element mediator will be unwired from any other DOM entanglements
	 * + The mediator reference to the model is released/nulled
	 * + Any value representation of this element mediator is released/nulled
	 * + The [[Mvvm|mvvm]] refernce is released/nulled
	 * + The parental reference is released/nulled
	 */
	dispose(): void;
	/**
	 * Initialize this element mediator.
	 */
	init(): void;
	/**
	 * Get the active module instance reference by id
	 * @return U
	 */
	get<U>(id: string): U;
	/**
	 * [message description]
	 * @param {string} channelName [description]
	 * @param {string} messageName [description]
	 * @param {any}    payload     [description]
	 */
	message(channelName: string, messageName: string, payload?: any): void;
	/**
	 * Broadcast a message
	 * @param {string} channelName [description]
	 * @param {string} messageName [description]
	 * @param {any}    payload     [description]
	 */
	broadcast(channelName: string, messageName: string, payload?: any): void;
	/**
	 * Broadcast a message in the Global context
	 * @param {string} channelName [description]
	 * @param {string} messageName [description]
	 * @param {any}    payload     [description]
	 */
	broadcastGlobally(channelName: string, messageName: string, payload?: any): void;
	on(messageName: string): OnContinuation;
	requestMediatorSources(sources: MediatorSource[]): void;
	getParentId(): string;
	getId(): string;
	requestMediators(consumer: DigestionCandidateConsumer): void;
	hasPropagation(): boolean;
	protected getParams(): P;
	protected getModelFn(): () => any;
	protected getExternalFn(): () => any;
	protected bridge(name: string): void;
	/**
	 * Get the associated {HTMLElement html element} of this element mediator.
	 * @return {HTMLElement} [description]
	 */
	protected getEl(): E;
	/**
	 * [getModule description]
	 * @return {Module} [description]
	 */
	protected getModule(): Module;
	/**
	 * Gets the prefix.
	 * @return the prefix
	 */
	protected getPrefix(): string;
	/**
	 * [mediate description]
	 * @param  {string}        expression [description]
	 * @return {ModelMediator}            [description]
	 */
	protected mediate<T>(expression: string, reducerFn?: (input: any) => T): ModelMediator<T>;
	/**
	 * [getModel description]
	 * @return {any} [description]
	 */
	protected getModel(): any;
	/**
	 * [getParent description]
	 * @return {Component} [description]
	 */
	protected getParent(): Nestable;
	/**
	 * [getMediator description]
	 * @return {ModelMediator} [description]
	 */
	protected getModelMediator(): ModelMediator<M>;
	protected $apply(fn: Function, args: any[]): any;
	/**
	 * Get the expression specified
	 * @return {string} [description]
	 */
	protected getExpression(): string;
	/**
	 * Gets the logger.
	 * @return {Logger} logger instance
	 */
	protected getLogger(): Logger;
	/**
	 * Wire the element mediator
	 */
	protected abstract wire(): void;
	/**
	 * Unwire the element mediator
	 */
	protected abstract unwire(): void;
	private removeDomListeners;
}
/**
 * Core class for Cydran
 */
export declare class Component implements Nestable {
	private ____internal$$cydran____;
	private ____internal$$cydran$$module____;
	/**
	 * Constructor
	 * @param template - string value representation of a template
	 * @param config - optional {@link ComponentConfig} argument
	 */
	constructor(template: string, config?: ComponentConfig);
	/**
	 * Get the {@link MetadataContinuation} of the {@link Component}
	 */
	metadata(): MetadataContinuation;
	/**
	 * Component has a {@link Region}
	 * @returns boolean - true | false
	 */
	hasRegion(name: string): boolean;
	/**
	 * Get a child component from a region.
	 * @param name - string name value of the child {@link Component}
	 * @returns Component instance, or null
	 */
	getChild<N extends Nestable>(name: string): N;
	/**
	 * Set a child component into a region.
	 * @param name - string name value of the child {@link Component}
	 * @param component - the {@link Component} reference
	 */
	setChild(name: string, component: Nestable): void;
	setChildFromRegistry(name: string, componentName: string, defaultComponentName?: string): void;
	message(channelName: string, messageName: string, payload?: any): void;
	dispose(): void;
	getParent(): Nestable;
	getEl(): HTMLElement;
	get<T>(id: string): T;
	scope(): Scope;
	getPrefix(): string;
	isConnected(): boolean;
	getId(): string;
	forElement<E extends HTMLElement>(name: string): NamedElementOperations<E>;
	/**
	 * @deprecated
	 */
	protected getItem<T>(): T;
	protected getValue<T>(): T;
	protected getExternals<T>(): T;
	protected broadcast(channelName: string, messageName: string, payload?: any): void;
	protected broadcastGlobally(channelName: string, messageName: string, payload?: any): void;
	protected $apply(fn?: Function, args?: any[]): void;
	protected watch<T>(expression: string, target: (previous: T, current: T) => void, reducerFn?: (input: any) => T): void;
	protected on(messageName: string): OnContinuation;
	protected getLogger(): Logger;
	protected ____internal$$cydran$$init____(template: string, config: ComponentConfig): void;
}
export declare class ComponentConfigBuilder {
	private instance;
	constructor();
	withMetadata(name: string, value: any): ComponentConfigBuilder;
	withAttribute(name: string): ComponentConfigBuilder;
	withPrefix(prefix: string): ComponentConfigBuilder;
	build(): ComponentConfig;
}
export declare class LoggerFactory {
	/**
	 * Get the named logger
	 * @param name of the associated logger
	 */
	static getLogger(name: string): Logger;
}
export declare const Events: any;
export declare const builder: (rootSelector: string) => StageBuilder;
export declare const isDefined: (value: any) => boolean;
export declare const requireNotNull: <T>(value: T, name: string) => T;
export declare const requireValid: (value: string, name: string, regex: RegExp) => string;
export declare function noConflict(): any;
export interface ComponentConfig {
	getMetadata(key: string): any;
	getPrefix(): string;
	getAttributes(): string[];
}
export interface DigestionCandidate extends Evaluatable, Notifyable {
}
export interface DigestionCandidateConsumer {
	add(key: string, mediators: DigestionCandidate[]): void;
}
export interface Disposable {
	dispose(): void;
}
export interface Evaluatable {
	evaluate(): boolean;
}
export interface ForChannelContinuation {
	invoke(target: (payload: any) => void): void;
}
export interface Gettable {
	get<T>(id: string): T;
}
export interface Logger {
	getName(): string;
	trace(payload: any, error?: Error): void;
	ifTrace(payloadFn: () => any, error?: Error): void;
	debug(payload: any, error?: Error): void;
	ifDebug(payloadFn: () => any, error?: Error): void;
	info(payload: any, error?: Error): void;
	ifInfo(payloadFn: () => any, error?: Error): void;
	warn(payload: any, error?: Error): void;
	ifWarn(payloadFn: () => any, error?: Error): void;
	error(payload: any, error?: Error): void;
	ifError(payloadFn: () => any, error?: Error): void;
	fatal(payload: any, error?: Error): void;
	ifFatal(payloadFn: () => any, error?: Error): void;
	isTrace(): boolean;
	isDebug(): boolean;
	isInfo(): boolean;
	isWarn(): boolean;
	isError(): boolean;
	isFatal(): boolean;
	isDisabled(): boolean;
}
export interface MediatorSource {
	requestMediators(consumer: DigestionCandidateConsumer): void;
	requestMediatorSources(sources: MediatorSource[]): void;
	getId(): string;
}
export interface MetadataContinuation {
	has: (name: string) => boolean;
	get: (name: string) => any;
}
export interface ModelMediator<T> extends Disposable, DigestionCandidate {
	invoke(params?: any): void;
	get(): T;
	set(value: any): void;
	watch(context: any, target: (previous: T, current: T) => void): void;
}
export interface Module extends Register {
	getName(): string;
	associate(...componentClasses: Type<Nestable>[]): Module;
	disassociate(...componentClasses: Type<Nestable>[]): Module;
	clear(): Module;
	broadcast(channelName: string, messageName: string, payload?: any): void;
	broadcastGlobally(channelName: string, messageName: string, payload?: any): void;
	message(channelName: string, messageName: string, payload?: any): void;
	getDefaultModule(): Module;
	getModule(name: string): Module;
	expose(id: string): Module;
	get<T>(id: string): T;
	getLocal<T>(id: string): T;
	getScope(): Scope;
	addStrategy(strategy: RegistryStrategy): Module;
	getLogger(): Logger;
	createPubSubFor(context: any): PubSub;
}
export interface NamedElementOperations<E extends HTMLElement> {
	get(): E;
	focus(): void;
	blur(): void;
}
export interface Nestable extends Disposable {
	metadata(): MetadataContinuation;
	hasRegion(name: string): boolean;
	getChild<N extends Nestable>(name: string): N;
	setChild(name: string, component: Nestable): void;
	setChildFromRegistry(name: string, componentName: string, defaultComponentName?: string): void;
	message(channelName: string, messageName: string, payload?: any): void;
	getParent(): Nestable;
	getEl(): HTMLElement;
	get<T>(id: string): T;
	scope(): Scope;
	getPrefix(): string;
	isConnected(): boolean;
	getId(): string;
}
export interface Notifyable {
	notify(): void;
}
export interface OnContinuation {
	invoke(target: (payload: any) => void): void;
	forChannel(name: string): ForChannelContinuation;
}
export interface PubSub extends Disposable {
	message(channelName: string, messageName: string, payload?: any): void;
	broadcast(channelName: string, messageName: string, payload?: any): void;
	broadcastGlobally(channelName: string, messageName: string, payload?: any): void;
	on(messageName: string): OnContinuation;
	enableGlobal(): void;
	disableGlobal(): void;
	isGlobalEnabled(): boolean;
}
export interface Register {
	registerConstant(id: string, instance: any): any | void;
	registerPrototype(id: string, classInstance: Type<any>, dependencies?: string[]): any | void;
	registerPrototypeWithFactory(id: string, factoryFn: () => any, dependencies?: string[]): any | void;
	registerSingleton(id: string, classInstance: Type<any>, dependencies?: string[]): any | void;
	registerSingletonWithFactory(id: string, factoryFn: () => any, dependencies?: string[]): any | void;
}
export interface RegistryStrategy {
	get<T>(id: string, gettable: Gettable): T;
}
export interface Scope {
	add(name: string, item: any): void;
	remove(name: string): void;
}
export interface Stage {
	setComponent(component: Nestable): Stage;
	setComponentFromRegistry(componentName: string, defaultComponentName?: string): void;
	get<T>(id: string): T;
	start(): void;
	getModule(name: string): Module;
	getDefaultModule(): Module;
	forEach(fn: (instace: Module) => void): void;
	broadcast(channelName: string, messageName: string, payload?: any): void;
	registerConstant(id: string, instance: any): void;
	registerPrototype(id: string, classInstance: Type<any>): void;
	registerSingleton(id: string, classInstance: Type<any>): void;
	getScope(): Scope;
}
export interface StageBuilder {
	getModule(name: string): Module;
	getDefaultModule(): Module;
	forEach(fn: (instace: Module) => void): StageBuilder;
	withComponentBefore(id: string, moduleName?: string): StageBuilder;
	withComponentAfter(id: string, moduleName?: string): StageBuilder;
	withComponent(id: string): StageBuilder;
	withInitializer(callback: (stage?: Stage) => void): StageBuilder;
	withTraceLogging(): StageBuilder;
	withDebugLogging(): StageBuilder;
	withInfoLogging(): StageBuilder;
	withWarnLogging(): StageBuilder;
	withErrorLogging(): StageBuilder;
	withFatalLogging(): StageBuilder;
	withLoggingDisabled(): StageBuilder;
	withElementMediator(name: string, supportedTags: string[], elementMediatorClass: Type<ElementMediator<any, HTMLElement | Text, any>>): StageBuilder;
	withConstant(id: string, instance: any): StageBuilder;
	withPrototype(id: string, classInstance: Type<any>, dependencies?: string[]): StageBuilder;
	withPrototypeFromFactory(id: string, factoryFn: () => any, dependencies?: string[]): StageBuilder;
	withSingleton(id: string, classInstance: Type<any>, dependencies?: string[]): StageBuilder;
	withSingletonFromFactory(id: string, factoryFn: () => any, dependencies?: string[]): StageBuilder;
	withImplicit(id: string, template: string, config?: ComponentConfig): StageBuilder;
	withCapability(capability: (builder: StageBuilder) => void): StageBuilder;
	withScopeItem(name: string, item: any): StageBuilder;
	build(): Stage;
}
export interface Type<T> extends Function {
	new (...args: any[]): T;
}

export as namespace cydran;

export {};
